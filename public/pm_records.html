<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width,initial-scale=1"/>
	<link rel="icon" type="image/x-icon" href="images/favicon.ico">
	<title>PM Records - Backup Viewer</title>
	<style>
		*{margin:0;padding:0;box-sizing:border-box}
		:root{--bg:#f9fafb;--card:#fff;--accent:#0b78d1;--muted:#6b7280}
		body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg);color:#111;padding:20px}
		.container{max-width:1400px;margin:0 auto}
		h1{font-size:24px;margin-bottom:8px;color:#111}
		.subtitle{color:var(--muted);font-size:14px;margin-bottom:20px}
		.toolbar{display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap}
		button{background:var(--accent);color:#fff;border:0;padding:10px 16px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500;transition:all 0.2s}
		button:hover{opacity:0.9;transform:translateY(-1px)}
		button.secondary{background:#e5e7eb;color:#111}
		.card{background:var(--card);border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,0.1);padding:20px;margin-bottom:20px}
		table{width:100%;border-collapse:collapse;font-size:13px}
		th,td{text-align:left;padding:10px;border-bottom:1px solid #e5e7eb}
		th{background:#f3f4f6;font-weight:600;position:sticky;top:0}
		tr:hover{background:#f9fafb}
		.empty{text-align:center;color:var(--muted);padding:40px;font-size:14px}
		@media (max-width:768px){
			body{padding:10px}
			h1{font-size:18px}
			.subtitle{font-size:12px}
			.toolbar{gap:6px}
			button{padding:8px 12px;font-size:12px}
			.card{padding:12px}
			table{display:block;overflow-x:auto;-webkit-overflow-scrolling:touch;font-size:11px}
			th,td{padding:6px;white-space:nowrap}
		}
		@media print{.toolbar{display:none}}
	</style>
	<!-- Firebase SDK -->
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
	<script src="firebase-config.js"></script>
	<script src="auth-guard.js"></script>
</head>
<body>
	<div class="container">
		<h1>PM Records - Backup Viewer</h1>
		<p class="subtitle">View, export, and manage your preventive maintenance records</p>
		
		<div class="toolbar">
			<button onclick="window.location.href='index.html'">‚Üê Back to App</button>
			<button onclick="openPreventiveMaintenanceRecord()">Open Preventive Maintenance Record</button>
			<button onclick="openBackupFile()">Open Json / CSV Backup</button>
			<button class="secondary" onclick="downloadJSON()">Download JSON</button>
			<button class="secondary" onclick="exportCSV()">Export CSV</button>
			<button class="secondary" onclick="printAsPDF()">Print / Save PDF</button>
			<button class="secondary" onclick="window.open('YOUR_ONEDRIVE_BACKUP_URL_HERE','_blank')">Download from OneDrive</button>
		</div>

		<div class="filter-section" style="background: #f0f4f8; padding: 12px 16px; border-radius: 6px; margin-bottom: 16px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
			<label style="font-weight: 500; color: #333;">Filter by Month/Year:</label>
			<select id="month-filter" onchange="filterChange()" style="padding: 6px 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 150px;">
				<option value="">-- All Months --</option>
			</select>
			<button onclick="resetFilters()" style="padding: 6px 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset Filters</button>
			<span id="filter-info" style="color: #6b7280; font-size: 14px; margin-left: auto;"></span>
		</div>

		<input type="file" id="backup-file-input" accept=".json,.csv" style="display:none" />

		<div class="card">
			<div id="table-container"></div>
			<div id="empty" class="empty" style="display:none">No records found. Return to the main app to add records.</div>
		</div>
	</div>

	<script>
		const KEY = 'epm_records_v1';

		async function loadRecords(){
			return await FirestoreDB.loadRecords(KEY);
		}

		async function saveRecords(records) {
			// Assuming FirestoreDB has a save method; fallback to localStorage if not
			if (typeof FirestoreDB.saveRecords === 'function') {
				await FirestoreDB.saveRecords(KEY, records);
			} else {
				localStorage.setItem(KEY, JSON.stringify(records));
			}
		}

		// Extract month/year from date string (handles YYYY-MM-DD format)
		function getMonthYear(dateStr) {
			if (!dateStr) return null;
			const parts = dateStr.split('-');
			if (parts.length >= 2) {
				return parts[0] + '-' + parts[1]; // YYYY-MM
			}
			return null;
		}

		// Format month-year for display (e.g., "December 2025")
		function formatMonthYear(monthYear) {
			if (!monthYear) return '';
			const [year, month] = monthYear.split('-');
			const date = new Date(year, parseInt(month) - 1, 1);
			return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
		}

		// Populate month/year filter dropdown
		async function populateFilterOptions() {
			try {
				const records = await loadRecords();
				console.log('Populating filter with records:', records.length);
				const monthYears = new Set();

				records.forEach(rec => {
					const my = getMonthYear(rec.date);
					console.log('Record date:', rec.date, 'Month-Year:', my);
					if (my) monthYears.add(my);
				});

				const sorted = Array.from(monthYears).sort().reverse(); // Newest first
				console.log('Sorted months:', sorted);
				const select = document.getElementById('month-filter');
				const currentValue = select.value;

				// Clear and repopulate (keep "All Months" option)
				select.innerHTML = '<option value="">-- All Months --</option>';
				sorted.forEach(my => {
					const option = document.createElement('option');
					option.value = my;
					option.textContent = formatMonthYear(my);
					console.log('Adding option:', my, '->', formatMonthYear(my));
					select.appendChild(option);
				});

				select.value = currentValue; // Restore selection if it still exists
			} catch(e) {
				console.error('Error populating filter:', e);
			}
		}

		async function renderTable(){
			const records = await loadRecords();
			const container = document.getElementById('table-container');
			const emptyEl = document.getElementById('empty');
			const filterInfo = document.getElementById('filter-info');

			// Get selected filter
			const selectedMonth = document.getElementById('month-filter').value;

			// Filter records based on selected month
			let filteredRecords = records;
			if (selectedMonth) {
				filteredRecords = records.filter(rec => getMonthYear(rec.date) === selectedMonth);
			}

			if(filteredRecords.length === 0){
				container.innerHTML = '';
				emptyEl.style.display = 'block';
				filterInfo.textContent = selectedMonth ? `No records for ${formatMonthYear(selectedMonth)}` : 'No records found';
				return;
			}

			emptyEl.style.display = 'none';
			filterInfo.textContent = selectedMonth 
				? `Showing ${filteredRecords.length} record(s) for ${formatMonthYear(selectedMonth)}` 
				: `Showing ${filteredRecords.length} total record(s)`;

			// Sort records by date descending
			filteredRecords.sort((a, b) => {
				const dateA = new Date(a.date || '1900-01-01');
				const dateB = new Date(b.date || '1900-01-01');
				return dateB - dateA;
			});

			let html = '';
			let currentMonth = '';

			filteredRecords.forEach(rec => {
				const monthYear = getMonthYear(rec.date);
				
				// Add month header if different from previous
				if (monthYear !== currentMonth) {
					if (currentMonth !== '') {
						html += '</tbody></table>';
					}
					currentMonth = monthYear;
					html += `<div style="margin-top: 20px; margin-bottom: 12px; font-weight: 600; color: #0b78d1; font-size: 14px; padding-bottom: 8px; border-bottom: 2px solid #0b78d1;">${formatMonthYear(monthYear)}</div>`;
					html += '<table><thead><tr>';
					html += '<th>Date</th><th>Branch Code</th><th>Branch Name</th><th>Equipment</th><th>Location</th>';
					html += '<th>Task</th><th>Status</th><th>Performed By</th><th>Verified By</th><th>Next Due</th><th>Notes</th>';
					html += '</tr></thead><tbody>';
				}

				html += '<tr>';
				html += `<td>${escapeHTML(rec.date || '')}</td>`;
				html += `<td>${escapeHTML(rec.BranchCode || '')}</td>`;
				html += `<td>${escapeHTML(rec.BranchName || '')}</td>`;
				html += `<td>${escapeHTML(rec.equipment || '')}</td>`;
				html += `<td>${escapeHTML(rec.location || '')}</td>`;
				html += `<td>${escapeHTML(rec.task || '')}</td>`;
				html += `<td>${escapeHTML(rec.status || '')}</td>`;
				html += `<td>${escapeHTML(rec.performedBy || '')}</td>`;
				html += `<td>${escapeHTML(rec.verifiedBy || '')}</td>`;
				html += `<td>${escapeHTML(rec.nextDue || '')}</td>`;
				html += `<td>${escapeHTML(rec.notes || '')}</td>`;
				html += '</tr>';
			});

			if (filteredRecords.length > 0) {
				html += '</tbody></table>';
			}

			container.innerHTML = html;
		}

		function resetFilters() {
			document.getElementById('month-filter').value = '';
			renderTable();
		}

		function filterChange() {
			renderTable();
		}

		function escapeHTML(str){
			const div = document.createElement('div');
			div.textContent = str;
			return div.innerHTML;
		}

		async function downloadJSON(){
			const records = await loadRecords();
			const blob = new Blob([JSON.stringify(records, null, 2)], {type:'application/json'});
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `pm_records_backup_${new Date().toISOString().split('T')[0]}.json`;
			a.click();
			URL.revokeObjectURL(url);
		}

		async function exportCSV(){
			const records = await loadRecords();
			if(records.length === 0){
				alert('No records to export');
				return;
			}

			const headers = ['Date','Branch Code','Branch Name','Equipment','Location','Task','Status','Performed By','Verified By','Next Due','Notes'];
			let csv = headers.join(',') + '\n';

			records.forEach(rec => {
				const row = [
					rec.date || '',
					rec.BranchCode || '',
					rec.BranchName || '',
					rec.equipment || '',
					rec.location || '',
					rec.task || '',
					rec.status || '',
					rec.performedBy || '',
					rec.verifiedBy || '',
					rec.nextDue || '',
					rec.notes || ''
				];
				csv += row.map(field => `"${(field+'').replace(/"/g,'""')}"`).join(',') + '\n';
			});

			const blob = new Blob([csv], {type:'text/csv'});
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `pm_records_${new Date().toISOString().split('T')[0]}.csv`;
			a.click();
			URL.revokeObjectURL(url);
		}

		function printAsPDF(){
			window.print();
		}

		async function openPreventiveMaintenanceRecord(){
			await renderTable();
			const records = await loadRecords();
			if (records.length > 0) {
				alert(`Loaded ${records.length} preventive maintenance record(s).`);
			} else {
				alert('No records found. Please add records in the main app first.');
			}
		}

		function openBackupFile(){
			const fileInput = document.getElementById('backup-file-input');
			fileInput.value = ''; // Clear previous selection
			fileInput.onchange = handleFileSelect;
			fileInput.click();
		}

		async function handleFileSelect(event){
			const file = event.target.files[0];
			if(!file) return;

			const reader = new FileReader();
			const fileName = file.name.toLowerCase();

			reader.onload = async function(e){
				try {
					let newRecords = [];

					if(fileName.endsWith('.json')){
						const data = JSON.parse(e.target.result);
						if(Array.isArray(data)){
							newRecords = data;
						} else {
							alert('Invalid JSON format. Expected an array of records.');
							return;
						}
					} else if(fileName.endsWith('.csv')){
						const csv = e.target.result;
						newRecords = parseCSV(csv);
						if(newRecords.length === 0){
							alert('No records found in CSV file.');
							return;
						}
					} else {
						alert('Please select a JSON or CSV file.');
						return;
					}

					await mergeAndPersist(newRecords);
				} catch(err){
					alert('Error processing file: ' + err.message);
				}
			};

			reader.readAsText(file);
		}

		function parseCSV(csv){
			const lines = csv.split(/\r\n|\n/).filter(line => line.trim() !== '');
			if(lines.length < 1) return [];

			// Normalize headers
			const rawHeaders = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
			const headerMap = {
				'date': 'date',
				'branch code': 'BranchCode',
				'branch name': 'BranchName',
				'equipment': 'equipment',
				'location': 'location',
				'task': 'task',
				'status': 'status',
				'performed by': 'performedBy',
				'verified by': 'verifiedBy',
				'next due': 'nextDue',
				'notes': 'notes'
			};

			const headers = rawHeaders.map(h => h.toLowerCase());
			const records = [];

			for(let i = 1; i < lines.length; i++){
				const values = parseCSVLine(lines[i]);
				if(values.length === 0) continue;

				const record = {};
				headers.forEach((header, idx) => {
					const key = headerMap[header];
					if(key && idx < values.length){
						record[key] = values[idx].trim();
					}
				});
				records.push(record);
			}

			return records;
		}

		function parseCSVLine(line){
			const result = [];
			let current = '';
			let inQuotes = false;

			for(let i = 0; i < line.length; i++){
				const char = line[i];
				const nextChar = i + 1 < line.length ? line[i + 1] : null;

				if(char === '"'){
					if(inQuotes && nextChar === '"'){
						current += '"';
						i++;
					} else {
						inQuotes = !inQuotes;
					}
				} else if(char === ',' && !inQuotes){
					result.push(current.trim());
					current = '';
				} else {
					current += char;
				}
			}
			result.push(current.trim());
			return result;
		}

		async function mergeAndPersist(newRecords){
			if(!Array.isArray(newRecords) || newRecords.length === 0){
				alert('No valid records to import.');
				return;
			}

			const existing = await loadRecords();
			const merged = [...existing];

			let addedCount = 0;
			newRecords.forEach(newRec => {
				const isDup = existing.some(e =>
					e.date === newRec.date &&
					e.BranchCode === newRec.BranchCode &&
					e.equipment === newRec.equipment &&
					e.task === newRec.task &&
					e.performedBy === newRec.performedBy
				);

				if(!isDup){
					merged.push(newRec);
					addedCount++;
				}
			});

			await saveRecords(merged);
			alert(`Import complete! Added ${addedCount} new record(s). Total records: ${merged.length}`);
			await renderTable();
		}

		// Initialize
		async function init() {
			console.log('Initializing pm_records...');
			await populateFilterOptions();
			await renderTable();
			console.log('Initialization complete');
		}

		// Wait for DOM to be ready
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', init);
		} else {
			init();
		}
	</script>
</body>
</html>
